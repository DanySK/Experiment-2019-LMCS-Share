module algorithm

import java.lang.Double.* 
import utils

/**
 * Classic Distance Estimation
 *
 * @param source  	whether the device is a source
 * @return       	estimated distance
 */
public def G_STD(source) {
	rep (old <- Infinity) {
		mux (source) {0} else {minHood(old + self.nbrRange())}
	}
}

/**
 * Bounded Information Speed Distance Estimation
 *
 * @param source  	whether the device is a source
 * @param speed		average communication speed
 * @param radius		communication radius
 * @return       	estimated distance
 */
public def G_BIS(source, speed, radius) {
	rep (old <- [Infinity, Infinity]) {
		mux (source) {[0,0]} else {
			let dx = old.get(0) + self.nbrRange();
			let dt = old.get(1) + self.nbrLag();
			minHood([max(dx, dt*speed-radius), dt])
		}
	}.get(0)
}

/**
 * Single-Path Summation
 *
 * @param dist  		distance from the source
 * @param value		value to be added
 */
public def C_SP(dist, value) {
    let id = self.getDeviceUID().getId();
    share (old <- [value, id]) {
        let nbrValues = mux (old.get(1) == id) { old.get(0) } else { -Infinity };
        [max(value, maxHood(nbrValues)), minHood PlusSelf(nbr([dist, id])).get(1)]
    }.get(0)
}

/**
 * Multi-Path Summation
 *
 * @param dist  		distance from the source
 * @param value		value to be added
 */
public def C_MP(dist, value) {
    rep (old <- [value, value]) {
    		let nbrValues = mux (nbr(dist) > dist) { old.get(1) } else { 0 };
		let newValue = max(value, maxHood(nbrValues));
		[newValue, newValue]
    }.get(0)
}

/**
 * Devices compete against one another to become local leaders,
 * resulting  in  a  random  Voronoi  partition  with  a  characteristic
 * grain size.
 *
 * @param grain  	num, partition dimension
 * @param algorithm	num, gradient algorithm used
 * @param radius 	num, communication radius
 * @return       	tuple, with distance from leader and leader UID
 */
public def S(grain) {
	let id = self.getDeviceUID().getId();
    rep (old <- id) {
    		let lead = pickHood(old);
    		let d = G_STD(id == lead);
	    mux (d > grain) {
	        id
	    } else {
		    	let dist = self.nbrRange() + nbr(d);
		    	minHood PlusSelf(mux (dist > grain || dist == 0) {
		    		[Infinity, lead] // leader farther than grain is unacceptable
		    	} else {
		    		[mux (dist < grain / 2) { 0 } else { dist }, nbr(lead)]
		    	}).get(1)
	    }
    }
}
