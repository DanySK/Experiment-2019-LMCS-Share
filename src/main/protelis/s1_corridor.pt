module s1_corridor

import java.lang.Math.*
import utils
import distance
import collection
import broadcast

// Reports the error of a spatio-temporal value. 
//def report(frequency, name, trueval, algoval) {
//	env.put("derr-" + name, abs(trueval.get(0) - algoval.get(0)));
//	env.put("terr-" + name, abs(trueval.get(1) - algoval.get(1)));
//}

// The source of distance estimations switches between devices 0 and 1 every 2 minutes.
let myId = self.getDeviceUID().getId();
let sourceId = if ((self.getCurrentTime()+40) % 240 < 120 ) { 0 } else { 1 };
let destinationId = (sourceId + 1) % 2;
let source = myId == sourceId;
let destination = myId == destinationId;
env.put("source", source);

// Determines random targets for devices.
let dspace = env.get("dspace");
rectangleWalkRange([0,0], [2000,200], dspace, 1);

// Get simulation parameters.
let rate 		= env.get("rate");
let radius 		= env.get("radius");
let batchFreq 	= env.get("batchFreq");
let rV = 0.4 * radius / rate;
let sV = 2.0 * radius / rate;


// 1) Computes spatio-temporal distances (d,t), exact and estimations.

// exact
let trueDistanceTo = self.distanceTo(sourceId);
let trueTime = self.getCurrentTime();
// rep-based
let rDT = repDistance(source, rV, radius);
let repDistanceTo = rDT.get(0);
//let rT = tT - rDT.get(1);
//report(batchFreq, "single-distance-rep", [trueDistanceTo, tT], [repDistanceTo, rT]);
//report(batchFreq,  "stack-distance-rep", [trueDistanceTo, tT], [repDistanceTo, rT]);
// share-based
let sDT = shareDistance(source, sV, radius);
let shareDistanceTo = sDT.get(0);
//let sT = tT - sDT.get(1);
//report(batchFreq, "single-distance-share", [trueDistanceTo, tT], [shareDistanceTo, sT]);
//report(batchFreq,  "stack-distance-share", [trueDistanceTo, tT], [shareDistanceTo, sT]);

let timeAtSource = if (source) { [myId, trueTime] } else { [-1, NaN] };
let repBcast = repBroadcast(repDistanceTo, timeAtSource);
let shareBcast = shareBroadcast(shareDistanceTo, timeAtSource);
env.put("rep-bcast", if (destination && repBcast.get(0) == sourceId) { self.getCurrentTime() - repBcast.get(1) } else { NaN });
env.put("share-bcast", if (destination && shareBcast.get(0) == sourceId) { self.getCurrentTime() - shareBcast.get(1) } else { NaN });
//env.put("actual-bcast", trueDistanceTo);

let accumulate = if (destination) { [myId, trueTime] } else { [-1, NaN] };
let repCcast = repCollection(repDistanceTo, accumulate);
let shareCcast = shareCollection(shareDistanceTo, accumulate);
env.put("rep-ccast", if (source && repCcast.get(0) == destinationId) { trueTime - repCcast.get(1) } else { NaN });
env.put("share-ccast", if (source && shareCcast.get(0) == destinationId) { trueTime - shareCcast.get(1) } else { NaN });
//env.put("actual-time", trueTime);
//env.put("raw-rc", repCcast);
//env.put("raw-rb", repBcast);
//env.put("raw-sc", shareCcast);
//env.put("raw-sb", shareBcast);
//env.put("myId", myId);
//env.put("destinationId", destinationId);
//env.put("sourceId", sourceId);
//env.put("repBcast.get(0) == sourceId", repBcast.get(0) == sourceId);
//env.put("shareBcast.get(0) == sourceId", shareBcast.get(0) == sourceId);
