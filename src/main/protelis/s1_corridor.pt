module s1_corridor

import java.lang.Math.*
import utils
import distance
import collection
import broadcast

// Reports the error of a spatio-temporal value. 
//def report(frequency, name, trueval, algoval) {
//	env.put("derr-" + name, abs(trueval.get(0) - algoval.get(0)));
//	env.put("terr-" + name, abs(trueval.get(1) - algoval.get(1)));
//}

// Discard inconsistent values after switch
def compute(sourceId, lambda) {
	if (sourceId == 0) {
		lambda.apply()
	} else {
		lambda.apply()
	}
}

// The source of distance estimations switches between devices 0 and 1 every 2 minutes.
let myId = self.getDeviceUID().getId();
let sourceId = if ((self.getCurrentTime()+40) % 240 < 120 ) { 0 } else { 1 };
let destinationId = (sourceId + 1) % 2;
let source = myId == sourceId;
let destination = myId == destinationId;
env.put("source", source);

// Determines random targets for devices.
let dspace = env.get("dspace");
rectangleWalkRange([0,0], [2000,200], dspace, 1);

// Get simulation parameters.
let rate 		= env.get("rate");
let radius 		= env.get("radius");
let batchFreq 	= env.get("batchFreq");
let rV = 0.4 * radius / rate;
let sV = 2.0 * radius / rate;

// oracle
let trueDistanceTo = self.distanceTo(sourceId);
let trueTime = self.getCurrentTime();
// rep-based
let rDT = repDistance(source, rV, radius);
let repDistanceTo = rDT.get(0);
let sDT = shareDistance(source, sV, radius);
let shareDistanceTo = sDT.get(0);

let timeAtSource = if (source) { [myId, trueTime] } else { [-1, NaN] };
let repBcast = compute(sourceId, () -> { repBroadcast(repDistanceTo, timeAtSource) });
let shareBcast = compute(sourceId, () -> { shareBroadcast(shareDistanceTo, timeAtSource); });
let repBcastSingle = compute(sourceId, () -> { repBroadcast(trueDistanceTo, timeAtSource) });
let shareBcastSingle = compute(sourceId, () -> { shareBroadcast(trueDistanceTo, timeAtSource); });
env.put("rep-bcast", if (destination && repBcast.get(0) == sourceId) { self.getCurrentTime() - repBcast.get(1) } else { NaN });
env.put("share-bcast", if (destination && shareBcast.get(0) == sourceId) { self.getCurrentTime() - shareBcast.get(1) } else { NaN });
env.put("rep-bcast-single", if (destination && repBcast.get(0) == sourceId) { self.getCurrentTime() - repBcastSingle.get(1) } else { NaN });
env.put("share-bcast-single", if (destination && shareBcast.get(0) == sourceId) { self.getCurrentTime() - shareBcastSingle.get(1) } else { NaN });

let accumulate = if (destination) { [myId, trueTime] } else { [-1, NaN] };
let repCcast = compute(sourceId, () -> { repCollection(repDistanceTo, accumulate); });
let shareCcast = compute(sourceId, () -> { shareCollection(shareDistanceTo, accumulate); });
let repCcastSingle = compute(sourceId, () -> { repCollection(trueDistanceTo, accumulate); });
let shareCcastSingle = compute(sourceId, () -> { shareCollection(trueDistanceTo, accumulate); });
env.put("rep-ccast", if (source && repCcast.get(0) == destinationId) { trueTime - repCcast.get(1) } else { NaN });
env.put("share-ccast", if (source && shareCcast.get(0) == destinationId) { trueTime - shareCcast.get(1) } else { NaN });
env.put("rep-ccast-single", if (source && repCcast.get(0) == destinationId) { trueTime - repCcastSingle.get(1) } else { NaN });
env.put("share-ccast-single", if (source && shareCcast.get(0) == destinationId) { trueTime - shareCcastSingle.get(1) } else { NaN });

// Useful for debugging purposes
//env.put("actual-time", trueTime);
//env.put("raw-rc", repCcast);
//env.put("raw-rb", repBcast);
//env.put("raw-sc", shareCcast);
//env.put("raw-sb", shareBcast);
//env.put("myId", myId);
//env.put("destinationId", destinationId);
//env.put("sourceId", sourceId);
//env.put("repBcast.get(0) == sourceId", repBcast.get(0) == sourceId);
//env.put("shareBcast.get(0) == sourceId", shareBcast.get(0) == sourceId);
