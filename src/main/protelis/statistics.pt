module statistics

import utils
import algorithm

// The source of distance estimations is device 0.
let source = self.getDeviceUID().getId() == 0;
env.put('source', source);

// Determines random targets for non-source devices.
if (source) {NaN} else {
	env.put("target", ifClose(() -> {randRect([48.205, 16.37], [48.211, 16.38])}, 0.000001));
};

// Stores simulation parameters.
let v    = env.get('speed');
let m    = v / 1.5; // length of a meter in GPS coordinate system
let R    = env.get('radius') * m;


let cnt  = rep (x <- 0) {x+1};                                // number of computation rounds elapsed 
let gap  = minHood(relRange(0) + v * self.nbrLag()) / 2;      // distance to closer neighbour
let rmax = rep (old <- 0) {                                   // maximum gap everywhere since simulation start, discarding the first 4 rounds
	max(mux (cnt < 4) { 0 } else {maxHood PlusSelf(old)}, gap)
};
let rmid = rep (old <- 0) {old + min(gap, R)} / cnt;          // average gap since simulation start (no neighbours is interpreted as an R-gap)
let cnbr = sumHood(nbr(1));                                   // number of neighbours
let nmax = rep (old <- 0) {max(maxHood PlusSelf(old), cnbr)}; // maximum number of neighbours everywhere since simulation start
let nmid = rep (old <- 0) {old + cnbr} / cnt;                 // average number of neighbours since simulation start
let tmax = rep (old <- 0) {                                   // maximum time interval everywhere since simulation start
	max(maxHood PlusSelf(old), self.getDeltaTime())
};

// Exports statistic results.
env.put("mean-rho", rmid/m);
env.put( "max-rho", rmax/m);
env.put("mean-nbr", nmid);
env.put( "max-nbr", nmax);
env.put( "max-dt",  tmax);
